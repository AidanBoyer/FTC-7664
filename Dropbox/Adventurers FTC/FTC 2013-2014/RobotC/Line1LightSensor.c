#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Hubs,  S2, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     LightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          ScoopLeft,     tmotorNXT, PIDControl, reversed)
#pragma config(Motor,  motorB,          ScoopRight,    tmotorNXT, PIDControl, reversed)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_1, RightFrontDrive, tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, RightRearDrive, tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, LeftFrontDrive, tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_4, LeftRearDrive, tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_1, ArmUpDown,     tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S2_2, FlagRaise,     tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S2_3, motorJ,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S2_4, motorK,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_1, servo5,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_2, servo6,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_3, servo7,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_4, servo8,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

// from include file
// Define the variables and constants to be used with LineFollowing.
//
const string sFileName = "LightRange.txt";
TFileIOResult nIoResult;
TFileHandle hFileHandle;
int nFileSize = 20;
long tLowLight = 300;
long tHighLight = 600;
//
// Declare the Methods to be performed.
//
float getLightPortion() {
  float result;
  long numerator, denominator;
  numerator = (long) SensorRaw[sensorLightActive] - tLowLight;
  denominator = tHighLight - tLowLight;
  result = (float)  numerator / denominator;
  if(result < 0) { result=0; }
  if(result > 1) { result=1; }
  return result;
}
// int getLightPercent() { return 100 * getLightPortion(); }
// end of include

void initializeRobot() // sets all the wheel encoder values to 0, just to be sure they aren't something different.
{
  nMotorEncoder[RightFrontDrive] = 0;
  nMotorEncoder[RightRearDrive] = 0;
  nMotorEncoder[LeftFrontDrive] = 0;
  nMotorEncoder[LeftRearDrive] = 0;

  return;
} // end of the "initializeRobot" function

void moveAllMotors(int power) // sets the power of all the motors to the value passed to this function
{
	motor[RightFrontDrive] = power;
  motor[RightRearDrive] = power;
  motor[LeftFrontDrive] = power;
  motor[LeftRearDrive] = power;
} // end of the "moveAllMotors" function

void moveLeftMotors(int power) // sets the power of left motors to the value passed to this function
{
  motor[LeftFrontDrive] = power;
  motor[LeftRearDrive] = power;
} // end of the "moveLeftMotors" function

void moveRightMotors(int power) // sets the power of right motors to the value passed to this function
{
	motor[RightFrontDrive] = power;
  motor[RightRearDrive] = power;
} // end of the "moveRightMotors" function

void initLightSensor() {
  SensorType[S3] = sensorLightActive;  // Turn light 'on' if it is currently 'off'
  CloseAllHandles(nIoResult);
  OpenRead(  hFileHandle, nIoResult, sFileName, nFileSize);
  ReadLong(hFileHandle, nIoResult, tLowLight);
  ReadLong(hFileHandle, nIoResult, tHighLight);
  Close(hFileHandle, nIoResult);
}


void showSensorValues()
{
		// clearDebugStream();
    writeDebugStreamLine("Light sensor value is %i", SensorValue[LightSensor]);
    writeDebugStreamLine("Light sensor raw is %i", SensorRaw[LightSensor]);
		wait10Msec(200);
}

void adjLine1(int LightPercent)
{
	int BasePwr = 10;
	int AdjPwr = 20;

		if(LightPercent>45)
		{
      moveLeftMotors(BasePwr+AdjPwr);
      moveRightMotors(BasePwr-AdjPwr);
    } else
		{
      moveLeftMotors(BasePwr);
      moveRightMotors(BasePwr+AdjPwr);
    }
}


task main()
{
	initializeRobot();
	int LightPercent;

	while(true)
	{
		//showSensorValues();

		LightPercent = SensorValue[LightSensor];
	  adjLine1(LightPercent);

	}
}
