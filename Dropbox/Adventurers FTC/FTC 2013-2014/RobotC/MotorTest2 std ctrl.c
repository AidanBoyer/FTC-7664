#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Hubs,  S2, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     DriveController, sensorNone)
#pragma config(Sensor, S2,     MiscController, sensorNone)
#pragma config(Sensor, S3,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_Matrix_S1_1, RightFrontDrive, tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_2, RightRearDrive, tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_3, LeftFrontDrive, tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_4, LeftRearDrive, tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S2_1, ArmUpDown,     tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S2_2, PullupBar,     tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S2_3, FlagRaise,     tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S2_4, motorK,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_1, servo5,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_2, servo6,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_3, servo7,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_4, servo8,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

const float HTticksPerRevSmallToLargeGear = 757.12 * 56 / 24;

// Drive control methods________________________________________________________________________________

void goForward4x4(const int msTime, const int power) // goForward4x4 = Forward four wheel drive
{
	motor[RightFrontDrive] = power;
	motor[LeftFrontDrive] = power * -1;
	motor[RightRearDrive] = power;
	motor[LeftRearDrive] = power * -1;
	wait1Msec(msTime);
}

void goForwardFront(const int msTime, const int power) // goForwardFront = 	Forward front wheel drive
{
	motor[RightFrontDrive] = power;
	motor[LeftFrontDrive] = power * -1;
}

void goForwardRear(const int msTime, const int power) // goForwardRear = 		Forward rear wheel drive
{
	motor[RightRearDrive] = power;
	motor[LeftRearDrive] = power * -1;
}

void goBackward4x4(const int msTime, const int power)  // goBackward4x4 = 	Backward four wheel drive
{
	motor[RightFrontDrive] = power * -1;
	motor[LeftFrontDrive] = power;
	motor[RightRearDrive] = power * -1;
	motor[LeftRearDrive] = power;
	wait1Msec(msTime);
}

void turnLeft4x4(const int msTime, const int power) // turnLeft4x4 =				Turn left four wheel drive
{
	motor[RightFrontDrive] = power;
	motor[LeftFrontDrive] = power;
	motor[RightRearDrive] = power;
	motor[LeftRearDrive] = power;
	wait1Msec(msTime);
}

void turnLeftRear(const int msTime, const int power)  // turnLeft =					Turn left rear wheel drive
{
	motor[RightRearDrive] = power;
	motor[LeftRearDrive] = power;
	wait1Msec(msTime);
}
//_____________________________________________________________________________________________________________
// Misc motor control methods

void armUp(const int msTime, const int power)  // armUp = 									Move arm up
{
	motor[ArmUpDown] = power * -1;
	wait1Msec(msTime);
}

void armDown(const int msTime, const int power)  // armDown = 							Move arm down
{
	motor[ArmUpDown] = power;
	wait1Msec(msTime);
}

void armMoveFractionOfRev(const float fractionOfRev, const int power)  // armMoveFractionOfRev = Move arm the specified fraction of a revolution
{
	nMotorEncoder[ArmUpDown] = 0;
	nMotorEncoderTarget[ArmUpDown] = 100;
	motor[ArmUpDown] = 20;
	while(nMotorRunState[ArmUpDown] != runStateIdle)  // while motor is still running (hasn't reached target yet):
	{
  	// do not continue
	}
	motor[ArmUpDown] = 0;
}

task main()
{
	long motorEncoder;
	while (true)
  {
  	motorEncoder = nMotorEncoder[ArmUpDown];
    nxtDisplayTextLine(2, motorEncoder);


  }
}
