#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Hubs,  S2, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S4,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          RollingGoalGripperRight, tmotorNXT, PIDControl)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          RollingGoalGripperLeft, tmotorNXT, PIDControl)
#pragma config(Motor,  mtr_Matrix_S1_1, LeftFrontDrive, tmotorMatrix, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, GathererMotor, tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, LeftRearDrive, tmotorMatrix, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  mtr_Matrix_S1_4, LiftMotorLeft, tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_1, RightFrontDrive, tmotorMatrix, PIDControl, driveRight, encoder)
#pragma config(Motor,  mtr_Matrix_S2_2, ConveyorDrive, tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_3, LiftMotorRight, tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S2_4, RightRearDrive, tmotorMatrix, PIDControl, driveRight, encoder)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_1, servo5,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_2, servo6,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_3, servo7,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_4, servo8,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float wheelDiameter = 3.75;  // tells the diameter of our wheels
const float ticksPerRevolution = 757.12;  // tells how many motor encoder ticks there are in a revolution
const float inchesPerFullTurn = 5.0 * PI * 2.0; // 18 = width in inches

void clearEncoders() // sets all the wheel encoder values to 0, just to be sure they aren't something different.
{
	nMotorEncoder[RightFrontDrive] = 0;
	nMotorEncoder[RightRearDrive] = 0;
	nMotorEncoder[LeftFrontDrive] = 0;
	nMotorEncoder[LeftRearDrive] = 0;

	return;
}


void driveMotors(float rf, float rr, float lf, float lr)
{
	float multiplyer = 1;

	motor[RightFrontDrive] = (rf * multiplyer)+1;
	motor[RightRearDrive] = (rr * multiplyer)+1;
	motor[LeftFrontDrive] = (lf * multiplyer);
	motor[LeftRearDrive] = (lr * multiplyer);
}


void turn(float angle, float speed)
{
	// angle is in degrees
	// positive is CCW, to the left
	float direction = 1;

	const float inchesToTravel = abs(angle) * inchesPerFullTurn / 360.0;
	const float ticksToTurn = inchesToTravel * ticksPerRevolution / (wheelDiameter * PI); // final number of
	// encoder ticks to travel
	clearEncoders();

	while(abs(((((nMotorEncoder[RightFrontDrive] + nMotorEncoder[RightRearDrive]) / 2.0) ) - ((nMotorEncoder[LeftFrontDrive] + nMotorEncoder[LeftRearDrive]) / 2.0))) < ticksToTurn)
		// repeat this section of code (do not continue sequential
	// execution) until the average of all four motor values is greater than the target number of ticks to move,
	// calculated from the specified number of feet to move.
	{
		if (angle < 0)
		{
			direction = -1;
		}
		else direction = 1;

		driveMotors((direction*speed)*0.85, (direction*speed)*0.85, direction*speed*(-1), direction*speed*(-1));
	}
}

void goSetDist(float dist, float speed)
{
	// dist is distance to travel in feet
	const float feetToTravel = dist;  // tells how many feet we want the robot to move
	const float inchesToTravel = feetToTravel * 12; // takes number of feet and turns it floato how many inches
	const float ticksToTravel = inchesToTravel * ticksPerRevolution / (wheelDiameter * PI); // final number of
	// encoder ticks to travel

	clearEncoders();
	while (((nMotorEncoder[LeftFrontDrive] + nMotorEncoder[LeftRearDrive] + nMotorEncoder[RightFrontDrive]
		+ nMotorEncoder[RightRearDrive]) / 4) < ticksToTravel)
	// repeat this section of code (do not continue sequential
	// execution) until the average of all four motor values is greater than the target number of ticks to move,
	// calculated from the specified number of feet to move.
	{
		driveMotors(speed,speed,speed,speed);  // Calls the "moveAllMotors" function, setting the power of all motors to 99%
	}
}

void chaseBeacon()
{
	while(true)
	{
		switch (SensorValue[IRSeeker])
		{
		case 0:
			driveMotors(0,0,0,0);
			break;

		case 1:
			driveMotors(60,60,-60,-60);
			break;

		case 2:
			driveMotors(-10,-10,60,60);
			break;

		case 3:
			driveMotors(60,60,10,10);
			break;

		case 4:
			driveMotors(60,60,25,25);
			break;

		case 5:
			driveMotors(50,50,50,50);
			break;

		case 6:
			driveMotors(25,25,60,60);
			break;

		case 7:
			driveMotors(10,10,60,60);
			break;

		case 8:
			driveMotors(60,60,-10,-10);
			break;

		case 9:
			driveMotors(60,60,-60,-60);
			break;
		}
	}
}
void goUntilIRBonSide(float Speed)
{
	do
	{
		driveMotors(Speed,Speed,Speed,Speed);
	}
	while (SensorValue[IRSeeker] != 1 && SensorValue[IRSeeker] != 9);

	chaseBeacon();
}



task main()
{
	/*
	float pauseDuration = 1000;
	goSetDist(2.0, 40);
	wait1Msec(pauseDuration);
	turn(-90, 25);
	wait1Msec(pauseDuration);
	goSetDist(2.0, 40);
	wait1Msec(pauseDuration);
	turn(90, 25);
	wait1Msec(pauseDuration);
	goSetDist(3.0, 40);
	wait1Msec(pauseDuration);
	turn(90, 25);
	wait1Msec(pauseDuration);
	goSetDist(2.0, 40);
	wait1Msec(pauseDuration);
	turn(-90, 25);
	wait1Msec(pauseDuration);
	goSetDist(2.0, 40);
	*/

	goSetDist(4.0, 40);

	if(SensorValue[IRSeeker] == 5)
	{
		chaseBeacon();
	}
	else
	{
		turn(-90, 20);
		wait1Msec(1200);
		goSetDist(2.0, 30);
		wait1Msec(1200);
		turn(90, 20);
		wait1Msec(1200);

		goUntilIRBonSide(30);
	}
}
